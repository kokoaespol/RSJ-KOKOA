<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kokoa - Rsj</title>
    <style>
      :root {
        --terminal-bg: #1e1e1e;
        --terminal-text: #f0f0f0;
        --terminal-border: #00ff41;
        --red: #ff5555;
        --green: #55ff55;
        --yellow: #ffff55;
        --blue: #5555ff;
        --magenta: #ff55ff;
        --cyan: #55ffff;
        --white: #ffffff;
        --selection: rgba(0, 255, 65, 0.3);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Courier New", monospace;
      }

      body {
        background: linear-gradient(135deg, #0d1b2a, #1b263b);
        color: var(--terminal-text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      .container {
        width: 100%;
        max-width: 900px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        padding: 20px 0;
        margin-bottom: 20px;
        border-bottom: 2px solid var(--cyan);
      }

      h1 {
        color: var(--cyan);
        text-shadow: 0 0 10px rgba(85, 255, 255, 0.5);
        font-size: 2.5rem;
        letter-spacing: 2px;
      }

      .subtitle {
        color: var(--yellow);
        font-size: 1.2rem;
        margin-top: 10px;
      }

      .terminal-container {
        background-color: var(--terminal-bg);
        border: 3px solid var(--terminal-border);
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        overflow: hidden;
        position: relative;
      }

      .terminal-header {
        background-color: #2a2a2a;
        padding: 10px;
        display: flex;
        align-items: center;
        border-bottom: 1px solid #444;
      }

      .terminal-buttons {
        display: flex;
        gap: 8px;
        margin-right: 10px;
      }

      .terminal-btn {
        width: 14px;
        height: 14px;
        border-radius: 50%;
      }

      .btn-close {
        background-color: #ff5f57;
      }
      .btn-minimize {
        background-color: #ffbd2e;
      }
      .btn-maximize {
        background-color: #28c940;
      }

      .terminal-title {
        flex-grow: 1;
        text-align: center;
        color: #bbb;
        font-size: 0.9rem;
      }

      .terminal-content {
        padding: 20px;
        min-height: 500px;
        max-height: 70vh;
        overflow-y: auto;
        font-size: 1.1rem;
        line-height: 1.6;
      }

      .terminal-content::-webkit-scrollbar {
        width: 8px;
      }

      .terminal-content::-webkit-scrollbar-track {
        background: #1a1a1a;
      }

      .terminal-content::-webkit-scrollbar-thumb {
        background: var(--terminal-border);
        border-radius: 4px;
      }

      .input-area {
        display: flex;
        align-items: center;
        padding: 15px 20px;
        background-color: #1a1a1a;
        border-top: 1px solid #444;
      }

      .prompt {
        color: var(--green);
        margin-right: 10px;
        font-weight: bold;
      }

      .terminal-input {
        flex-grow: 1;
        background: transparent;
        border: none;
        color: var(--terminal-text);
        font-size: 1.1rem;
        padding: 8px 0;
        outline: none;
        caret-color: var(--terminal-border);
        font-family: "Courier New", monospace;
      }

      .terminal-input:focus {
        outline: none;
      }

      .btn {
        background: linear-gradient(to bottom, #333, #222);
        color: var(--terminal-text);
        border: 1px solid var(--terminal-border);
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1rem;
        transition: all 0.3s;
        margin-top: 20px;
      }

      .btn:hover {
        background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
        box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
      }

      .btn:active {
        transform: translateY(2px);
      }

      .btn-start {
        background: linear-gradient(to bottom, var(--green), #008f11);
        color: #000;
        font-weight: bold;
        padding: 15px 40px;
        font-size: 1.2rem;
        margin-top: 30px;
      }

      .footer {
        margin-top: 30px;
        text-align: center;
        color: #aaa;
        font-size: 0.9rem;
        padding: 20px;
      }

      /* Colores del texto */
      .red {
        color: var(--red);
      }
      .green {
        color: var(--green);
      }
      .yellow {
        color: var(--yellow);
      }
      .blue {
        color: var(--blue);
      }
      .magenta {
        color: var(--magenta);
      }
      .cyan {
        color: var(--cyan);
      }
      .white {
        color: var(--white);
      }

      .bold {
        font-weight: bold;
      }
      .underline {
        text-decoration: underline;
      }

      .line {
        margin: 10px 0;
        animation: fadeIn 0.5s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .header-line {
        text-align: center;
        padding: 10px 0;
        margin: 15px 0;
        border-top: 1px solid #444;
        border-bottom: 1px solid #444;
        font-weight: bold;
        letter-spacing: 1px;
      }

      .separator {
        height: 1px;
        background: linear-gradient(
          to right,
          transparent,
          var(--terminal-border),
          transparent
        );
        margin: 15px 0;
      }

      .cipher-display {
        background-color: rgba(0, 0, 0, 0.3);
        padding: 15px;
        border-radius: 4px;
        border-left: 3px solid var(--terminal-border);
        margin: 15px 0;
        font-size: 1.2rem;
        overflow-x: auto;
      }

      .dictionary {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 10px;
        margin: 20px 0;
      }

      .dictionary-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
      }

      .dictionary-original {
        font-weight: bold;
        color: var(--yellow);
      }

      .dictionary-cipher {
        color: var(--green);
      }

      .sequence-display {
        padding: 15px;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        margin: 15px 0;
        text-align: center;
        font-size: 1.3rem;
        border: 1px dashed var(--cyan);
      }

      .difficulty-indicator {
        display: inline-block;
        padding: 5px 15px;
        border-radius: 20px;
        font-weight: bold;
        margin: 10px 0;
      }

      .difficulty-easy {
        background-color: rgba(85, 255, 85, 0.2);
        color: var(--green);
      }

      .difficulty-medium {
        background-color: rgba(255, 255, 85, 0.2);
        color: var(--yellow);
      }

      .difficulty-hard {
        background-color: rgba(255, 85, 85, 0.2);
        color: var(--red);
      }

      .cursor {
        display: inline-block;
        width: 8px;
        height: 1.2rem;
        background-color: var(--terminal-border);
        margin-left: 4px;
        animation: blink 1s infinite;
        vertical-align: middle;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }

      @media (max-width: 768px) {
        .terminal-content {
          padding: 15px;
          font-size: 1rem;
        }

        h1 {
          font-size: 2rem;
        }

        .btn-start {
          padding: 12px 30px;
          font-size: 1.1rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Ready Set Join</h1>
        <p class="subtitle">Buena suerte, la necesitarás</p>
      </header>

      <div class="terminal-container">
        <div class="terminal-header">
          <div class="terminal-buttons">
            <div class="terminal-btn btn-close"></div>
            <div class="terminal-btn btn-minimize"></div>
            <div class="terminal-btn btn-maximize"></div>
          </div>
          <div class="terminal-title">Kokoa@cifrado-cesar:~/juego</div>
        </div>

        <div class="terminal-content" id="terminal-output">
          <!-- El contenido de la terminal se generará dinámicamente aquí -->
        </div>

        <div class="input-area">
          <div class="prompt">$</div>
          <input
            type="text"
            class="terminal-input"
            id="terminal-input"
            placeholder="Escribe tu comando aquí..."
          />
        </div>
      </div>

      <button class="btn btn-start" id="start-btn">INICIAR JUEGO</button>

      <div class="footer">Desarrollado por Kokoa | Ready Set Join</div>
    </div>

    <script>
      // Constantes de colores
      const RED = "red";
      const GREEN = "green";
      const YELLOW = "yellow";
      const BLUE = "blue";
      const MAGENTA = "magenta";
      const CYAN = "cyan";
      const WHITE = "white";
      const BOLD = "bold";
      const UNDERLINE = "underline";

      // Elementos DOM
      const terminalOutput = document.getElementById("terminal-output");
      const terminalInput = document.getElementById("terminal-input");
      const startBtn = document.getElementById("start-btn");

      // Variables del juego
      let abecedario = "abcdefghijklmnñopqrstuvwxyz";
      let num_pasos = 0;
      let abecedario_cifrado = {};
      let pista =
        "te doy un consejo, no creas en todo lo que ella te diga, no es quien dice ser. Abre el cofre la contraseña es: cuatro cinco seis uno";
      let modo = "";
      let dificultad = 0;
      let pista_cifrada = "";
      let juegoIniciado = false;

      // Función para selección ponderada
      function weightedRandom(items, weights) {
        let totalWeight = weights.reduce((acc, val) => acc + val, 0);
        let rand = Math.random() * totalWeight;
        for (let i = 0; i < items.length; i++) {
          rand -= weights[i];
          if (rand <= 0) return items[i];
        }
        return items[0];
      }

      // Función para imprimir texto con efecto de escritura
      function print_animated(
        text,
        color = WHITE,
        bold = false,
        underline = false,
        delay = 30
      ) {
        return new Promise((resolve) => {
          const line = document.createElement("div");
          line.className = "line";

          // Aplicar estilos
          if (color) line.classList.add(color);
          if (bold) line.classList.add("bold");
          if (underline) line.classList.add("underline");

          terminalOutput.appendChild(line);

          let i = 0;
          const interval = setInterval(() => {
            if (i < text.length) {
              line.textContent += text.charAt(i);
              i++;
              terminalOutput.scrollTop = terminalOutput.scrollHeight;
            } else {
              clearInterval(interval);
              resolve();
            }
          }, delay);
        });
      }

      // Función para imprimir encabezados
      async function print_header(text, color = CYAN) {
        await print_animated("\n" + "=".repeat(60), color);
        await print_animated(
          text.padStart(30 + text.length / 2).padEnd(60),
          color,
          true
        );
        await print_animated("=".repeat(60) + "\n", color);
      }

      // Función para imprimir separadores
      async function print_separator(char = "=", length = 60, color = BLUE) {
        await print_animated(char.repeat(length) + "\n", color);
      }

      // Función para mostrar el diccionario de cifrado
      async function mostrar_posiciones() {
        await print_header("DICCIONARIO DE CIFRADO", MAGENTA);

        const header = document.createElement("div");
        header.className = "line bold yellow";
        header.innerHTML = `<span style="display:inline-block; width:45%; text-align:center">Original</span> → <span style="display:inline-block; width:45%; text-align:center">Cifrado</span>`;
        terminalOutput.appendChild(header);

        await print_separator("─", 25, YELLOW);

        // Crear contenedor para el diccionario
        const dictContainer = document.createElement("div");
        dictContainer.className = "dictionary";
        terminalOutput.appendChild(dictContainer);

        // Agregar cada letra con un pequeño retraso
        for (let letra of abecedario) {
          const cifrada = abecedario_cifrado[letra];
          const item = document.createElement("div");
          item.className = "dictionary-item";
          item.innerHTML = `
                    <div class="dictionary-original">${letra.toUpperCase()}</div>
                    <div>→</div>
                    <div class="dictionary-cipher">${cifrada.toUpperCase()}</div>
                `;
          dictContainer.appendChild(item);

          // Pequeño retraso entre elementos
          await new Promise((resolve) => setTimeout(resolve, 50));
        }

        await print_animated("\n");
      }

      // Funciones de dificultad - Implementación completa según Python
      async function dificultad_easy() {
        await print_header("DIFICULTAD: FÁCIL", GREEN);
        await print_animated(
          "Tuviste suerte, la secuencia de números es muy fácil de adivinar\n",
          GREEN,
          true
        );

        let opciones = [];
        const n = num_pasos;

        // Opción 1: +2 constante
        if (n >= 8) {
          opciones.push(() => {
            return {
              secuencia: [n - 6, n - 4, n - 2],
              respuesta: n,
            };
          });
        }

        // Opción 2: +5 constante (si n>=15)
        if (n >= 15) {
          opciones.push(() => {
            return {
              secuencia: [n - 15, n - 10, n - 5],
              respuesta: n,
            };
          });
        }

        // Opción 3: ×2 patrón (si n divisible por 8)
        if (n % 8 === 0) {
          opciones.push(() => {
            return {
              secuencia: [n / 8, n / 4, n / 2],
              respuesta: n,
            };
          });
        }

        // Opción 4: +1 patrón
        opciones.push(() => {
          return {
            secuencia: [n - 3, n - 2, n - 1],
            respuesta: n,
          };
        });

        // Opción 5: Fibonacci (solo si n==8)
        if (n === 8) {
          opciones.push(() => {
            return {
              secuencia: [1, 1, 2, 3, 5],
              respuesta: 8,
            };
          });
        }

        // Elegir una opción al azar
        const patron =
          opciones.length > 0
            ? opciones[Math.floor(Math.random() * opciones.length)]()
            : { secuencia: [n - 3, n - 2, n - 1], respuesta: n };
        return patron;
      }

      async function dificultad_medium() {
        await print_header("DIFICULTAD: MEDIA", YELLOW);
        await print_animated(
          "No fuiste tan suertudo, la secuencia de números es medianamente fácil de adivinar\n",
          YELLOW,
          true
        );

        let opciones = [];
        const n = num_pasos;

        // Opción 1: Patrón: x, 2x+1, 4x+3 = n (si (n-3) divisible por 4)
        if ((n - 3) % 4 === 0) {
          opciones.push(() => {
            const x = (n - 3) / 4;
            return {
              secuencia: [x, 2 * x + 1],
              respuesta: n,
            };
          });
        }

        // Opción 2: Diferencias crecientes
        opciones.push(() => {
          return {
            secuencia: [n - 6, n - 5, n - 3],
            respuesta: n,
          };
        });

        // Opción 3: Progresión aritmética
        const step = Math.floor(Math.random() * 4) + 2; // entre 2 y 5
        const a1 = n - step * 3;
        if (a1 > 0) {
          opciones.push(() => {
            return {
              secuencia: [a1, a1 + step, a1 + 2 * step],
              respuesta: n,
            };
          });
        }

        // Opción 4: Patrón intercalado
        opciones.push(() => {
          const a = n - 6;
          return {
            secuencia: [a, a + 1, a + 3],
            respuesta: n,
          };
        });

        // Elegir una opción al azar, si no hay opciones válidas, usar una por defecto
        if (opciones.length === 0) {
          opciones.push(() => {
            return {
              secuencia: [n - 3, n - 2, n - 1],
              respuesta: n,
            };
          });
        }

        const patron = opciones[Math.floor(Math.random() * opciones.length)]();
        return patron;
      }

      async function dificultad_hard() {
        await print_header("DIFICULTAD: DIFÍCIL", RED);
        await print_animated(
          "Tu suerte es nula, la secuencia de números es muy difícil de adivinar\n",
          RED,
          true
        );

        let opciones = [];
        const n = num_pasos;

        // Opción 1: Factorial
        let fact = 1;
        let i = 1;
        const factoriales = [1];
        while (fact < n) {
          i++;
          fact *= i;
          factoriales.push(fact);
        }
        if (fact === n && factoriales.length > 1) {
          opciones.push(() => {
            return {
              secuencia: factoriales.slice(0, factoriales.length - 1),
              respuesta: n,
            };
          });
        }

        // Opción 2: Secuencia de primos
        function esPrimo(num) {
          if (num < 2) return false;
          for (let i = 2; i <= Math.sqrt(num); i++) {
            if (num % i === 0) return false;
          }
          return true;
        }

        function generarPrimos(cantidad) {
          const primos = [];
          let num = 2;
          while (primos.length < cantidad) {
            if (esPrimo(num)) primos.push(num);
            num++;
          }
          return primos;
        }

        if (esPrimo(n)) {
          // Buscamos los primos anteriores
          const primos = generarPrimos(10); // generamos 10 primos
          const index = primos.indexOf(n);
          if (index >= 4) {
            opciones.push(() => {
              return {
                secuencia: primos.slice(index - 4, index),
                respuesta: n,
              };
            });
          }
        }

        // Opción 3: Intercalado (solo si n es par)
        if (n % 2 === 0) {
          opciones.push(() => {
            const a = n / 2 - 1;
            return {
              secuencia: [a, a * 2, a + 1],
              respuesta: n,
            };
          });
        }

        // Si no hay opciones, usamos un fallback
        if (opciones.length === 0) {
          opciones.push(() => {
            return {
              secuencia: [n - 3, n - 2, n - 1],
              respuesta: n,
            };
          });
        }

        const patron = opciones[Math.floor(Math.random() * opciones.length)]();
        return patron;
      }

      // Función para cifrar pista
      function cifrar_pista(pista) {
        return pista
          .split("")
          .map((letra) => {
            return abecedario_cifrado[letra] || letra;
          })
          .join("");
      }

      // Función para descifrar pista
      function descifrar_pista(pista) {
        const abecedario_descifrado = {};
        for (let letra in abecedario_cifrado) {
          abecedario_descifrado[abecedario_cifrado[letra]] = letra;
        }

        return pista
          .split("")
          .map((letra) => {
            return abecedario_descifrado[letra] || letra;
          })
          .join("");
      }

      // Función principal del juego
      async function juego() {
        juegoIniciado = true;
        terminalOutput.innerHTML = "";
        startBtn.textContent = "REINICIAR JUEGO";

        await print_header("Bienvenido al Juego.", BLUE);

        // Generar número de pasos aleatorio
        num_pasos = Math.floor(Math.random() * (25 - 8 + 1)) + 8;

        // Crear diccionario de cifrado
        abecedario_cifrado = {};
        for (let letra of abecedario) {
          const nueva_posicion =
            (abecedario.indexOf(letra) + num_pasos) % abecedario.length;
          abecedario_cifrado[letra] = abecedario[nueva_posicion];
        }

        // Seleccionar modo
        await print_animated("Seleccione el modo de juego (", WHITE);
        await print_animated("auto", GREEN, true);
        await print_animated("/", WHITE);
        await print_animated("manual", YELLOW, true);
        await print_animated("): ", WHITE);

        // Esperar selección de modo
        terminalInput.placeholder = "Escribe 'auto' o 'manual'...";
        terminalInput.focus();

        modo = await new Promise((resolve) => {
          const handleModeInput = (e) => {
            if (e.key === "Enter") {
              const input = terminalInput.value.trim().toLowerCase();
              terminalInput.value = "";

              if (input === "auto" || input === "manual") {
                terminalInput.removeEventListener("keypress", handleModeInput);
                resolve(input);
              } else {
                print_animated("Por favor, escribe 'auto' o 'manual'\n", RED);
              }
            }
          };

          terminalInput.addEventListener("keypress", handleModeInput);
        });

        // Cifrar la pista
        pista_cifrada = cifrar_pista(pista);

        // Mensajes de introducción
        const textos_intro = [
          "El sistema recibió un mensaje desde los cuarteles generales de Kokoa en Cuenca",
          "Parece que fue cifrado con un método antiguo, tal vez el cifrado César",
          "Este cifrado se basa en un desplazamiento de letras en el abecedario",
          "Tu objetivo como brillante agente encubierto es descifrar el número de desplazamientos realizados",
          "El mensaje cifrado es el siguiente:",
        ];

        await print_header("Mensaje Recibido", RED);
        for (let texto of textos_intro) {
          if (texto === "El mensaje cifrado es el siguiente:") {
            await print_animated(texto + "\n", CYAN, true, false, 50);
          } else {
            await print_animated(texto + "\n", WHITE, true, false, 50);
          }
          await new Promise((resolve) => setTimeout(resolve, 500));
        }

        // Mostrar pista cifrada
        const cipherDisplay = document.createElement("div");
        cipherDisplay.className = "cipher-display red bold";
        cipherDisplay.textContent = pista_cifrada;
        terminalOutput.appendChild(cipherDisplay);

        await print_separator();
        await print_animated("Presiona Enter para continuar...", YELLOW, true);

        // Esperar Enter
        await new Promise((resolve) => {
          const handleContinue = (e) => {
            if (e.key === "Enter") {
              terminalInput.removeEventListener("keypress", handleContinue);
              resolve();
            }
          };
          terminalInput.addEventListener("keypress", handleContinue);
        });

        // Seleccionar dificultad con pesos (como en Python)
        const dificultades = [1, 2, 3];
        const pesos = [1, 2, 2]; // easy:1, medium:2, hard:2
        dificultad = weightedRandom(dificultades, pesos);

        let patron;
        if (dificultad === 1) {
          patron = await dificultad_easy();
        } else if (dificultad === 2) {
          patron = await dificultad_medium();
        } else {
          patron = await dificultad_hard();
        }

        // Mostrar la secuencia
        const seqDisplay = document.createElement("div");
        seqDisplay.className = "sequence-display";
        seqDisplay.innerHTML = `${patron.secuencia.join(
          ", "
        )}, <span class="cyan">?</span>`;
        terminalOutput.appendChild(seqDisplay);

        await print_animated("\n");

        // Esperar respuesta del usuario
        const respuestaUsuario = await new Promise((resolve) => {
          terminalInput.placeholder = "Ingresa el número de pasos...";
          terminalInput.focus();

          const handleInput = (e) => {
            if (e.key === "Enter") {
              const usr = terminalInput.value.trim();
              terminalInput.value = "";

              if (usr === patron.respuesta.toString()) {
                print_animated(
                  `¡Correcto! El número de pasos es ${patron.respuesta}\n`,
                  GREEN,
                  true
                );
                terminalInput.removeEventListener("keypress", handleInput);
                resolve(patron.respuesta);
              } else {
                print_animated(
                  `✖ Respuesta incorrecta, intenta de nuevo.\n`,
                  RED
                );
              }
            }
          };

          terminalInput.addEventListener("keypress", handleInput);
        });

        await print_separator();
        await print_animated(
          `¡Felicidades! Has encontrado el número de pasos: ${respuestaUsuario}\n`,
          GREEN,
          true
        );

        if (modo === "manual") {
          await print_animated(
            "Hemos generado este diccionario por ti:\n",
            YELLOW,
            true
          );
          await mostrar_posiciones();
          await print_animated(
            "Ahora puedes descifrar la pista manualmente\n",
            YELLOW,
            true
          );

          await print_animated("\nPista cifrada:\n", RED, true);
          const cipherDisplay2 = document.createElement("div");
          cipherDisplay2.className = "cipher-display red bold";
          cipherDisplay2.textContent = pista_cifrada;
          terminalOutput.appendChild(cipherDisplay2);

          await print_animated(
            "\nPresiona Enter cuando hayas terminado de descifrar...",
            YELLOW,
            true
          );

          // Esperar Enter
          await new Promise((resolve) => {
            const handleFinish = (e) => {
              if (e.key === "Enter") {
                terminalInput.removeEventListener("keypress", handleFinish);
                resolve();
              }
            };
            terminalInput.addEventListener("keypress", handleFinish);
          });
        } else {
          await print_animated("Descifrando pista...\n", CYAN, true);
          // Simular descifrado
          await new Promise((resolve) => setTimeout(resolve, 2000));

          const pista_descifrada = descifrar_pista(pista_cifrada);

          await print_animated("\nLa pista descifrada es:\n", GREEN, true);
          const decipheredDisplay = document.createElement("div");
          decipheredDisplay.className = "cipher-display green bold";
          decipheredDisplay.textContent = pista_descifrada;
          terminalOutput.appendChild(decipheredDisplay);

          await print_animated(
            "\nPresiona Enter para continuar...",
            CYAN,
            true
          );

          // Esperar Enter
          await new Promise((resolve) => {
            const handleContinue = (e) => {
              if (e.key === "Enter") {
                terminalInput.removeEventListener("keypress", handleContinue);
                resolve();
              }
            };
            terminalInput.addEventListener("keypress", handleContinue);
          });
        }

        await print_header("Mensaje Leído", GREEN);
        await print_animated(
          "Este mensaje será eliminado en 1 minuto!\n",
          CYAN,
          true
        );
      }

      // Event listeners
      startBtn.addEventListener("click", () => {
        if (!juegoIniciado) {
          juego();
        } else {
          location.reload();
        }
      });

      // Inicialización
      terminalInput.addEventListener("focus", () => {
        terminalInput.placeholder = "";
      });

      terminalInput.addEventListener("blur", () => {
        terminalInput.placeholder = "Escribe tu comando aquí...";
      });

      // Mensaje inicial
      print_animated("Bienvenido a esta experiencia\n\n", CYAN, true);

      print_animated(
        "Para comenzar, haz clic en el botón 'INICIAR JUEGO'\n",
        GREEN
      );

      const cursor = document.createElement("span");
      cursor.className = "cursor";
      terminalOutput.appendChild(cursor);
    </script>
  </body>
</html>
